#!/usr/bin/env python3
import os
import subprocess
import ipaddress
import argparse
import sys

def get_public_ip():
    try:
        return subprocess.check_output("curl -s https://api.ipify.org", shell=True).decode().strip()
    except Exception as e:
        print("‚ùå Failed to get public IP:", e)
        return "<unknown>"

SERVER_PORT = 51820
SERVER_ENDPOINT = f"{get_public_ip()}:{SERVER_PORT}"
WG_CONFIG = "/etc/wireguard/wg0.conf"
CLIENTS_DIR = "./clients"
SUBNET = ipaddress.IPv4Network("10.8.0.0/24")
SERVER_IP = "10.8.0.1"
QR_ENABLED = True

def run_cmd(cmd):
    return subprocess.check_output(cmd, shell=True).decode().strip()

def generate_keys():
    private_key = run_cmd("wg genkey")
    public_key = run_cmd(f"echo '{private_key}' | wg pubkey")
    return private_key, public_key

def find_used_ips():
    used = set()
    if not os.path.exists(WG_CONFIG):
        return used
    with open(WG_CONFIG) as f:
        for line in f:
            if "AllowedIPs" in line:
                ip = line.split("=")[1].strip().split("/")[0]
                used.add(ip)
    return used

def get_next_ip():
    used_ips = find_used_ips()
    for ip in SUBNET.hosts():
        if str(ip) == SERVER_IP:
            continue
        if str(ip) not in used_ips:
            return str(ip)
    raise RuntimeError("No available IPs left in subnet.")

def generate_client_config(name, client_ip, client_privkey, server_pubkey, full_tunnel=True):
    allowed_ips = "0.0.0.0/0" if full_tunnel else str(SUBNET)
    config_type = "Full Tunnel" if full_tunnel else "Split Tunnel"
    return f"""
# {config_type} configuration
[Interface]
PrivateKey = {client_privkey}
Address = {client_ip}/32
DNS = 1.1.1.1

[Peer]
PublicKey = {server_pubkey}
Endpoint = {SERVER_ENDPOINT}
AllowedIPs = {allowed_ips}
PersistentKeepalive = 25
"""

def append_peer_to_server(name, client_pubkey, client_ip):
    peer_config = f"""
[Peer]
# {name}
PublicKey = {client_pubkey}
AllowedIPs = {client_ip}/32
"""
    with open(WG_CONFIG, "a") as f:
        f.write(peer_config)

def save_client_file(name, config, suffix):
    os.makedirs(CLIENTS_DIR, exist_ok=True)
    filename = f"{name}_{suffix}.conf"
    path = os.path.join(CLIENTS_DIR, filename)
    with open(path, "w") as f:
        f.write(config.strip())
    return path

def show_qr(config_path):
    try:
        subprocess.run(["qrencode", "-t", "ansiutf8", "-r", config_path], check=True)
    except FileNotFoundError:
        print("‚ö†Ô∏è qrencode not installed. Skipping QR code.")

def restart_wireguard():
    os.system("systemctl restart wg-quick@wg0")

def list_existing_configs():
    if not os.path.exists(CLIENTS_DIR):
        print("‚ùå No clients directory found.")
        return
    print("üìÅ Available client configs:")
    for f in os.listdir(CLIENTS_DIR):
        if f.endswith(".conf"):
            print(" -", f)

def main():
    parser = argparse.ArgumentParser(
           description="üõ°Ô∏è WireGuard Peer Manager - Generate new peer configs or show QR codes.",
           epilog="""
   Examples:
     ./add_peer.py --name alice --config both
     ./add_peer.py --show alice_full.conf

   Config types:
     full  - Route all traffic through VPN (0.0.0.0/0)
     split - Only access internal VPN subnet (e.g., 10.8.0.0/24)
     both  - Generate both full and split configs
   """,
           formatter_class=argparse.RawDescriptionHelpFormatter
       )

    parser.add_argument(
        "--name",
        help="Peer name (used for config file name). Required for config generation."
    )
    parser.add_argument(
        "--config",
        choices=["full", "split", "both"],
        help="Type of config to generate. Default is 'both'."
    )
    parser.add_argument(
        "--show",
        metavar="FILENAME",
        help="Show QR code for an existing client config file in ./clients/"
    )

    args = parser.parse_args()

    if args.show:
        config_path = os.path.join(CLIENTS_DIR, args.show)
        if not os.path.exists(config_path):
            print("‚ùå Config not found:", config_path)
            list_existing_configs()
            return
        print(f"üì± Showing QR code for {args.show}...")
        show_qr(config_path)
        return

    name = args.name or input("Enter peer name (no spaces): ").strip()
    if not name:
        print("‚ùå Invalid name.")
        return

    config_choice = args.config or input("Which config do you want to generate? (full/split/both) [default: both]: ").strip().lower()
    if config_choice not in {"full", "split", "both", ""}:
        print("‚ùå Invalid choice. Use 'full', 'split', or 'both'.")
        return
    if config_choice == "":
        config_choice = "both"

    client_ip = get_next_ip()
    print(f"üî¢ Assigning IP: {client_ip}")

    print("üîë Generating keys...")
    client_priv, client_pub = generate_keys()

    server_pub = open("/etc/wireguard/publickey").read().strip()

    print("üì¶ Writing peer to server config...")
    append_peer_to_server(name, client_pub, client_ip)

    generated_paths = []

    if config_choice in ("full", "both"):
        print("üìÑ Creating full tunnel client config...")
        full_config = generate_client_config(name, client_ip, client_priv, server_pub, full_tunnel=True)
        path = save_client_file(name, full_config, "full")
        generated_paths.append(("Full Tunnel", path))
        if QR_ENABLED:
            print("\nüì± QR Code for full tunnel config:")
            show_qr(path)

    if config_choice in ("split", "both"):
        print("üìÑ Creating split tunnel client config...")
        split_config = generate_client_config(name, client_ip, client_priv, server_pub, full_tunnel=False)
        path = save_client_file(name, split_config, "split")
        generated_paths.append(("Split Tunnel", path))
        if QR_ENABLED:
            print("\nüì± QR Code for split tunnel config:")
            show_qr(path)

    print("üîÅ Restarting WireGuard...")
    restart_wireguard()

    print("‚úÖ Done.\nClient configs saved:")
    for label, path in generated_paths:
        print(f" - {label}: {path}")

if __name__ == "__main__":
    main()
